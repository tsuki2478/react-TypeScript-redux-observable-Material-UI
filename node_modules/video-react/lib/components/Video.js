import _objectSpread from "@babel/runtime/helpers/objectSpread";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import PropTypes from 'prop-types';
import React, { Component } from 'react';
import classNames from 'classnames';
import { isVideoChild, mediaProperties, throttle } from '../utils';
var propTypes = {
  actions: PropTypes.object,
  player: PropTypes.object,
  children: PropTypes.any,
  startTime: PropTypes.number,
  loop: PropTypes.bool,
  muted: PropTypes.bool,
  autoPlay: PropTypes.bool,
  playsInline: PropTypes.bool,
  src: PropTypes.string,
  poster: PropTypes.string,
  className: PropTypes.string,
  preload: PropTypes.oneOf(['auto', 'metadata', 'none']),
  crossOrigin: PropTypes.string,
  onLoadStart: PropTypes.func,
  onWaiting: PropTypes.func,
  onCanPlay: PropTypes.func,
  onCanPlayThrough: PropTypes.func,
  onPlaying: PropTypes.func,
  onEnded: PropTypes.func,
  onSeeking: PropTypes.func,
  onSeeked: PropTypes.func,
  onPlay: PropTypes.func,
  onPause: PropTypes.func,
  onProgress: PropTypes.func,
  onDurationChange: PropTypes.func,
  onError: PropTypes.func,
  onSuspend: PropTypes.func,
  onAbort: PropTypes.func,
  onEmptied: PropTypes.func,
  onStalled: PropTypes.func,
  onLoadedMetadata: PropTypes.func,
  onLoadedData: PropTypes.func,
  onTimeUpdate: PropTypes.func,
  onRateChange: PropTypes.func,
  onVolumeChange: PropTypes.func,
  onResize: PropTypes.func
};

var Video =
/*#__PURE__*/
function (_Component) {
  _inherits(Video, _Component);

  function Video(props) {
    var _this;

    _classCallCheck(this, Video);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Video).call(this, props));
    _this.video = null; // the html5 video

    _this.play = _this.play.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.pause = _this.pause.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.seek = _this.seek.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.forward = _this.forward.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.replay = _this.replay.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggleFullscreen = _this.toggleFullscreen.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.getProperties = _this.getProperties.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.renderChildren = _this.renderChildren.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleLoadStart = _this.handleLoadStart.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleCanPlay = _this.handleCanPlay.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleCanPlayThrough = _this.handleCanPlayThrough.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handlePlay = _this.handlePlay.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handlePlaying = _this.handlePlaying.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handlePause = _this.handlePause.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleEnded = _this.handleEnded.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleWaiting = _this.handleWaiting.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleSeeking = _this.handleSeeking.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleSeeked = _this.handleSeeked.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleFullscreenChange = _this.handleFullscreenChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleError = _this.handleError.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleSuspend = _this.handleSuspend.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleAbort = _this.handleAbort.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleEmptied = _this.handleEmptied.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleStalled = _this.handleStalled.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleLoadedMetaData = _this.handleLoadedMetaData.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleLoadedData = _this.handleLoadedData.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleTimeUpdate = _this.handleTimeUpdate.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleRateChange = _this.handleRateChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleVolumeChange = _this.handleVolumeChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleDurationChange = _this.handleDurationChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleProgress = throttle(_this.handleProgress.bind(_assertThisInitialized(_assertThisInitialized(_this))), 250);
    _this.handleKeypress = _this.handleKeypress.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(Video, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.forceUpdate(); // make sure the children can get the video property
    } // get all video properties

  }, {
    key: "getProperties",
    value: function getProperties() {
      var _this2 = this;

      if (!this.video) {
        return null;
      }

      return mediaProperties.reduce(function (properties, key) {
        properties[key] = _this2.video[key];
        return properties;
      }, {});
    } // get playback rate

  }, {
    key: "play",
    // play the video
    value: function play() {
      var promise = this.video.play();

      if (promise !== undefined) {
        promise.catch(function () {}).then(function () {});
      }
    } // pause the video

  }, {
    key: "pause",
    value: function pause() {
      var promise = this.video.pause();

      if (promise !== undefined) {
        promise.catch(function () {}).then(function () {});
      }
    } // Change the video source and re-load the video:

  }, {
    key: "load",
    value: function load() {
      this.video.load();
    } // Add a new text track to the video

  }, {
    key: "addTextTrack",
    value: function addTextTrack() {
      var _this$video;

      (_this$video = this.video).addTextTrack.apply(_this$video, arguments);
    } // Check if your browser can play different types of video:

  }, {
    key: "canPlayType",
    value: function canPlayType() {
      var _this$video2;

      (_this$video2 = this.video).canPlayType.apply(_this$video2, arguments);
    } // toggle play

  }, {
    key: "togglePlay",
    value: function togglePlay() {
      if (this.video.paused) {
        this.play();
      } else {
        this.pause();
      }
    } // seek video by time

  }, {
    key: "seek",
    value: function seek(time) {
      try {
        this.video.currentTime = time;
      } catch (e) {// console.log(e, 'Video is not ready.')
      }
    } // jump forward x seconds

  }, {
    key: "forward",
    value: function forward(seconds) {
      this.seek(this.video.currentTime + seconds);
    } // jump back x seconds

  }, {
    key: "replay",
    value: function replay(seconds) {
      this.forward(-seconds);
    } // enter or exist full screen

  }, {
    key: "toggleFullscreen",
    value: function toggleFullscreen() {
      var _this$props = this.props,
          player = _this$props.player,
          actions = _this$props.actions;
      actions.toggleFullscreen(player);
    } // Fired when the user agent
    // begins looking for media data

  }, {
    key: "handleLoadStart",
    value: function handleLoadStart() {
      var _this$props2 = this.props,
          actions = _this$props2.actions,
          onLoadStart = _this$props2.onLoadStart;
      actions.handleLoadStart(this.getProperties());

      if (onLoadStart) {
        onLoadStart.apply(void 0, arguments);
      }
    } // A handler for events that
    // signal that waiting has ended

  }, {
    key: "handleCanPlay",
    value: function handleCanPlay() {
      var _this$props3 = this.props,
          actions = _this$props3.actions,
          onCanPlay = _this$props3.onCanPlay;
      actions.handleCanPlay(this.getProperties());

      if (onCanPlay) {
        onCanPlay.apply(void 0, arguments);
      }
    } // A handler for events that
    // signal that waiting has ended

  }, {
    key: "handleCanPlayThrough",
    value: function handleCanPlayThrough() {
      var _this$props4 = this.props,
          actions = _this$props4.actions,
          onCanPlayThrough = _this$props4.onCanPlayThrough;
      actions.handleCanPlayThrough(this.getProperties());

      if (onCanPlayThrough) {
        onCanPlayThrough.apply(void 0, arguments);
      }
    } // A handler for events that
    // signal that waiting has ended

  }, {
    key: "handlePlaying",
    value: function handlePlaying() {
      var _this$props5 = this.props,
          actions = _this$props5.actions,
          onPlaying = _this$props5.onPlaying;
      actions.handlePlaying(this.getProperties());

      if (onPlaying) {
        onPlaying.apply(void 0, arguments);
      }
    } // Fired whenever the media has been started

  }, {
    key: "handlePlay",
    value: function handlePlay() {
      var _this$props6 = this.props,
          actions = _this$props6.actions,
          onPlay = _this$props6.onPlay;
      actions.handlePlay(this.getProperties());

      if (onPlay) {
        onPlay.apply(void 0, arguments);
      }
    } // Fired whenever the media has been paused

  }, {
    key: "handlePause",
    value: function handlePause() {
      var _this$props7 = this.props,
          actions = _this$props7.actions,
          onPause = _this$props7.onPause;
      actions.handlePause(this.getProperties());

      if (onPause) {
        onPause.apply(void 0, arguments);
      }
    } // Fired when the duration of
    // the media resource is first known or changed

  }, {
    key: "handleDurationChange",
    value: function handleDurationChange() {
      var _this$props8 = this.props,
          actions = _this$props8.actions,
          onDurationChange = _this$props8.onDurationChange;
      actions.handleDurationChange(this.getProperties());

      if (onDurationChange) {
        onDurationChange.apply(void 0, arguments);
      }
    } // Fired while the user agent
    // is downloading media data

  }, {
    key: "handleProgress",
    value: function handleProgress() {
      var _this$props9 = this.props,
          actions = _this$props9.actions,
          onProgress = _this$props9.onProgress;

      if (this.video) {
        actions.handleProgressChange(this.getProperties());
      }

      if (onProgress) {
        onProgress.apply(void 0, arguments);
      }
    } // Fired when the end of the media resource
    // is reached (currentTime == duration)

  }, {
    key: "handleEnded",
    value: function handleEnded() {
      var _this$props10 = this.props,
          loop = _this$props10.loop,
          player = _this$props10.player,
          actions = _this$props10.actions,
          onEnded = _this$props10.onEnded;

      if (loop) {
        this.seek(0);
        this.play();
      } else if (!player.paused) {
        this.pause();
      }

      actions.handleEnd(this.getProperties());

      if (onEnded) {
        onEnded.apply(void 0, arguments);
      }
    } // Fired whenever the media begins waiting

  }, {
    key: "handleWaiting",
    value: function handleWaiting() {
      var _this$props11 = this.props,
          actions = _this$props11.actions,
          onWaiting = _this$props11.onWaiting;
      actions.handleWaiting(this.getProperties());

      if (onWaiting) {
        onWaiting.apply(void 0, arguments);
      }
    } // Fired whenever the player
    // is jumping to a new time

  }, {
    key: "handleSeeking",
    value: function handleSeeking() {
      var _this$props12 = this.props,
          actions = _this$props12.actions,
          onSeeking = _this$props12.onSeeking;
      actions.handleSeeking(this.getProperties());

      if (onSeeking) {
        onSeeking.apply(void 0, arguments);
      }
    } // Fired when the player has
    // finished jumping to a new time

  }, {
    key: "handleSeeked",
    value: function handleSeeked() {
      var _this$props13 = this.props,
          actions = _this$props13.actions,
          onSeeked = _this$props13.onSeeked;
      actions.handleSeeked(this.getProperties());

      if (onSeeked) {
        onSeeked.apply(void 0, arguments);
      }
    } // Handle Fullscreen Change

  }, {
    key: "handleFullscreenChange",
    value: function handleFullscreenChange() {} // Fires when the browser is
    // intentionally not getting media data

  }, {
    key: "handleSuspend",
    value: function handleSuspend() {
      var _this$props14 = this.props,
          actions = _this$props14.actions,
          onSuspend = _this$props14.onSuspend;
      actions.handleSuspend(this.getProperties());

      if (onSuspend) {
        onSuspend.apply(void 0, arguments);
      }
    } // Fires when the loading of an audio/video is aborted

  }, {
    key: "handleAbort",
    value: function handleAbort() {
      var _this$props15 = this.props,
          actions = _this$props15.actions,
          onAbort = _this$props15.onAbort;
      actions.handleAbort(this.getProperties());

      if (onAbort) {
        onAbort.apply(void 0, arguments);
      }
    } // Fires when the current playlist is empty

  }, {
    key: "handleEmptied",
    value: function handleEmptied() {
      var _this$props16 = this.props,
          actions = _this$props16.actions,
          onEmptied = _this$props16.onEmptied;
      actions.handleEmptied(this.getProperties());

      if (onEmptied) {
        onEmptied.apply(void 0, arguments);
      }
    } // Fires when the browser is trying to
    // get media data, but data is not available

  }, {
    key: "handleStalled",
    value: function handleStalled() {
      var _this$props17 = this.props,
          actions = _this$props17.actions,
          onStalled = _this$props17.onStalled;
      actions.handleStalled(this.getProperties());

      if (onStalled) {
        onStalled.apply(void 0, arguments);
      }
    } // Fires when the browser has loaded
    // meta data for the audio/video

  }, {
    key: "handleLoadedMetaData",
    value: function handleLoadedMetaData() {
      var _this$props18 = this.props,
          actions = _this$props18.actions,
          onLoadedMetadata = _this$props18.onLoadedMetadata,
          startTime = _this$props18.startTime;

      if (startTime && startTime > 0) {
        this.video.currentTime = startTime;
      }

      actions.handleLoadedMetaData(this.getProperties());

      if (onLoadedMetadata) {
        onLoadedMetadata.apply(void 0, arguments);
      }
    } // Fires when the browser has loaded
    // the current frame of the audio/video

  }, {
    key: "handleLoadedData",
    value: function handleLoadedData() {
      var _this$props19 = this.props,
          actions = _this$props19.actions,
          onLoadedData = _this$props19.onLoadedData;
      actions.handleLoadedData(this.getProperties());

      if (onLoadedData) {
        onLoadedData.apply(void 0, arguments);
      }
    } // Fires when the current
    // playback position has changed

  }, {
    key: "handleTimeUpdate",
    value: function handleTimeUpdate() {
      var _this$props20 = this.props,
          actions = _this$props20.actions,
          onTimeUpdate = _this$props20.onTimeUpdate;
      actions.handleTimeUpdate(this.getProperties());

      if (onTimeUpdate) {
        onTimeUpdate.apply(void 0, arguments);
      }
    }
    /**
     * Fires when the playing speed of the audio/video is changed
     */

  }, {
    key: "handleRateChange",
    value: function handleRateChange() {
      var _this$props21 = this.props,
          actions = _this$props21.actions,
          onRateChange = _this$props21.onRateChange;
      actions.handleRateChange(this.getProperties());

      if (onRateChange) {
        onRateChange.apply(void 0, arguments);
      }
    } // Fires when the volume has been changed

  }, {
    key: "handleVolumeChange",
    value: function handleVolumeChange() {
      var _this$props22 = this.props,
          actions = _this$props22.actions,
          onVolumeChange = _this$props22.onVolumeChange;
      actions.handleVolumeChange(this.getProperties());

      if (onVolumeChange) {
        onVolumeChange.apply(void 0, arguments);
      }
    } // Fires when an error occurred
    // during the loading of an audio/video

  }, {
    key: "handleError",
    value: function handleError() {
      var _this$props23 = this.props,
          actions = _this$props23.actions,
          onError = _this$props23.onError;
      actions.handleError(this.getProperties());

      if (onError) {
        onError.apply(void 0, arguments);
      }
    }
  }, {
    key: "handleResize",
    value: function handleResize() {
      var _this$props24 = this.props,
          actions = _this$props24.actions,
          onResize = _this$props24.onResize;
      actions.handleResize(this.getProperties());

      if (onResize) {
        onResize.apply(void 0, arguments);
      }
    }
  }, {
    key: "handleKeypress",
    value: function handleKeypress() {}
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this3 = this;

      var props = _objectSpread({}, this.props, {
        video: this.video
      }); // to make sure the children can get video property


      if (!this.video) {
        return null;
      } // only keep <source />, <track />, <MyComponent isVideoChild /> elements


      return React.Children.toArray(this.props.children).filter(isVideoChild).map(function (c) {
        var cprops;

        if (typeof c.type === 'string') {
          // add onError to <source />
          if (c.type === 'source') {
            cprops = _objectSpread({}, c.props);
            var preOnError = cprops.onError;

            cprops.onError = function () {
              if (preOnError) {
                preOnError.apply(void 0, arguments);
              }

              _this3.handleError.apply(_this3, arguments);
            };
          }
        } else {
          cprops = props;
        }

        return React.cloneElement(c, cprops);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props25 = this.props,
          loop = _this$props25.loop,
          poster = _this$props25.poster,
          preload = _this$props25.preload,
          src = _this$props25.src,
          autoPlay = _this$props25.autoPlay,
          playsInline = _this$props25.playsInline,
          muted = _this$props25.muted,
          crossOrigin = _this$props25.crossOrigin,
          videoId = _this$props25.videoId;
      return React.createElement("video", {
        className: classNames('video-react-video', this.props.className),
        id: videoId,
        crossOrigin: crossOrigin,
        ref: function ref(c) {
          _this4.video = c;
        },
        muted: muted,
        preload: preload,
        loop: loop,
        playsInline: playsInline,
        autoPlay: autoPlay,
        poster: poster,
        src: src,
        onLoadStart: this.handleLoadStart,
        onWaiting: this.handleWaiting,
        onCanPlay: this.handleCanPlay,
        onCanPlayThrough: this.handleCanPlayThrough,
        onPlaying: this.handlePlaying,
        onEnded: this.handleEnded,
        onSeeking: this.handleSeeking,
        onSeeked: this.handleSeeked,
        onPlay: this.handlePlay,
        onPause: this.handlePause,
        onProgress: this.handleProgress,
        onDurationChange: this.handleDurationChange,
        onError: this.handleError,
        onSuspend: this.handleSuspend,
        onAbort: this.handleAbort,
        onEmptied: this.handleEmptied,
        onStalled: this.handleStalled,
        onLoadedMetadata: this.handleLoadedMetaData,
        onLoadedData: this.handleLoadedData,
        onTimeUpdate: this.handleTimeUpdate,
        onRateChange: this.handleRateChange,
        onVolumeChange: this.handleVolumeChange
      }, this.renderChildren());
    }
  }, {
    key: "playbackRate",
    get: function get() {
      return this.video.playbackRate;
    } // set playback rate
    // speed of video
    ,
    set: function set(rate) {
      this.video.playbackRate = rate;
    }
  }, {
    key: "muted",
    get: function get() {
      return this.video.muted;
    },
    set: function set(val) {
      this.video.muted = val;
    }
  }, {
    key: "volume",
    get: function get() {
      return this.video.volume;
    },
    set: function set(val) {
      if (val > 1) {
        val = 1;
      }

      if (val < 0) {
        val = 0;
      }

      this.video.volume = val;
    } // video width

  }, {
    key: "videoWidth",
    get: function get() {
      return this.video.videoWidth;
    } // video height

  }, {
    key: "videoHeight",
    get: function get() {
      return this.video.videoHeight;
    }
  }]);

  return Video;
}(Component);

export { Video as default };
Video.propTypes = propTypes;
Video.displayName = 'Video';